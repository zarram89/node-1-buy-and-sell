# REST API «Куплю-продам»

## Заметки по курсу

### 1. CLI

#### Обновление и переключение веток

```bash
# в вашей локальной копии переключитесь в ветку master
git checkout master
# заберите изменения из репозитория Академии¹ (или academy)
git pull academy master
# отправьте изменения ветки master в ваш форк на Гитхабе (или origin)
git push origin master
# когда вы обновили master, создайте ветку для выполнения задания
git checkout -b module2-task1

# в academy должна быть ссылка на репозиторий Академии. Если её там нет, добавьте
git remote add academy git@github.com:htmlacademy-nodejs-api/241042-six-cities-9.git
```

#### Установка nvm в macOS и Linux (Node Version Manager)

```bash
# установка на macOS
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.1/install.sh | bash

# установка на Linux через wget
wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.1/install.sh | bash

# или через apt-get на Ubuntu или Debian
apt-get install curl

# Для Windows ставим nvm-windows или nodist

### проверяем установку и версию
nvm --version
```

#### Работа с nvm

```bash
# узнать версию
node --version

# установить LTS-резил
nvm install --lts 

# установить нужную вепрсию
nvm install 17

# посмотреть список установленных версий node
nvm list

# переключиться на нужную версию node use 16
nvm use 16.14.2

# или
nvm use 16

# помощь nvm --help
nvm --help
```

####  Инструмент REPL (Read Eval Print Loop)

```bash
 # вводим в консоль node и запускается REPL 
 node

 # для выхода вводим .exit или прерываем процесс Ctrl+C
```

Выводим сообщение из консоли в REPL
```03-first-application.js
console.log(`Hello, world from Node ${process.version}`);
```

```bash
node ./03-first-application.js 
### получим версию node
Hello, world from Node v22.13.0
```

#### TypeScript

Модификаторы
- private используется для определения приватных (закрытых) полей и методов. То есть полей и методов, которые применяются только внутри класса. Снаружи к ним нельзя получить доступ. 
- public публичные свойства и методы доступны как внутри класса, так и снаружи. Свойства и методы, объявленные без модификатора подразумеваются публичными.
- protected защищённые поля и методы. Такие поля доступны внутри класса и они наследуются. Это означает, что внутри наследника можно напрямую обращаться к таким свойствам и методам.

#### Интерфейсы
Интерфейсы — это один из способов определить контракт. Для этого класс должен реализовать интерфейс или как ещё часто говорят — имплементировать интерфейс.

```js
interface Musician {
  // Музыкант предоставляет информацию о
  // количестве гитар в коллекции
  readonly guitarCount: number;

  // Музыкант умеет играть
  play(): void;

  // Музыкант умеет здороваться
  hello(): void;
}

class GuitarPlayer implements Musician {
  // Тело класса
    constructor(
    public readonly guitarCount: number,
  ) {}

  public play() {
    console.log('Гитарист играет на гитаре.');
  }

  public hello() {
    console.log('Привет, я гитарист');
  }
}
```
Один класс может реализовывать несколько интерфейсов.
```js
class GuitarPlayer implements Musician, Vocalist {}
```
Проектирование на основе интерфейсов позволяет добиться гибкости. Наследование — один из сложных принципов ООП. С ним легко свернуть не туда, выстроив сложную и неправильную цепочку наследования. Интерфейсы более атомарны.

При использовании интерфейсов в TypeScript стоит помнить о нескольких нюансах. Если в одной области видимости объявлен интерфейс и класс с одинаковыми именами, то подразумевается, что класс реализует интерфейс. Поскольку имя класса совпадает с именем интерфейса и они объявлены в одной области видимости, подразумевается, что класс реализует интерфейс. Стоит упомянуть, что пользоваться этой возможностью стоит в исключительных ситуациях. Явное всегда лучше неявного.

Подведём итоги:

- Интерфейсы — один из способов определить контракт. Контракт не содержит деталей, только общие сведения. Имплементация происходит в классе, который реализует интерфейс.
- Для объявления интерфейса используется ключевое слово interface.
- Имя интерфейса начинается с прописной буквы. Может быть как существительным, так и глаголом.
- Интерфейс первичен. Проектируйте классы на основании интерфейса, а не наоборот.
- Интерфейс атомарен. Лучше несколько небольших интерфейсов, чем один большой.
- Для реализации интерфейса используется ключевое слово implements. Его указываем после имени класса.
- Один класс может реализовывать несколько интерфейсов. В этом случае все интерфейсы перечисляются через запятую.

### Node

#### Альтернативы, исправлены детские болезни Node

Bun и Deno

#### Фрэймворки с архитектурой, которой нет в Node

Express и Fastify (микрофрэймворки)
Nest.js и Adonis.js

#### Виды приложений на Node

- CLI
- HTTP Services (REST API)
- Desktop Apps
- Microservices

### NPM

#### Алиасы для команд

- -D — алиас для --save-dev;
- -E — алиас для --save-exact;
- i — алиас для install;
- un — алиас для uninstall;

### Command Line Interface (CLI)

#### Процесс приложения

Вся информация о текущем процессе вашего приложения доступна в объекте process. Это глобальный объект, поэтому для работы с ним не требуется что-то подключать (global.process). 

Запуск приложения мы осуществляем с помощью:

```bash
node <script-name.js>
```

В примере мы воспользовались только свойством argv, которое содержит массив параметров, передаваемых при запуске процесса. !!! Первые два параметра передаются автоматически. Первым всегда будет путь к платформе, который исполняет сценарий, а вторым сам сценарий.

```js
const [nodePath, appPath] = process.argv;
console.log(`Путь к Node: ${nodePath}`);
console.log(`Путь к текущему сценарию: ${appPath}`);
```

Чтобы обработать пользовательский ввод в консоли, нам необходимо подключить встроенный модуль readline. 

Затем создаём новый экземпляр интерфейса — readline.createInterface(). Он решает задачу взаимодействия с пользовательским вводом.

Метод question позволяет запросить у пользователя входные данные для дальнейшей работы приложения.

Если запустить это приложение, то оно не завершится пока мы сами это не сделаем. Если мы захотим прервать выполнение этого приложения, мы сможем воспользоваться услугами знакомого нам объекта process. У него есть метод exit(). После вызова этого метода процесс приложения будет немедленно завершён. Давайте попробуем модифицировать предыдущий код и вставить в бесконечный цикл условие и вызов метода exit().

```js
import readline from 'readline';

const welcomeText = `Привет, я Кекс. Мне нравится загадывать числа.
Всё честно: вы называете максимальное число, а я загадаю случайное
число в этом диапазоне. Попробуйте его угадать. Количество попыток
неограничено.`;

const readLineInterface = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
});

const getRandomNumber = (min, max) => {
  min = Math.ceil(min);
  max = Math.floor(max);
  return Math.floor(Math.random() * (max - min)) + min;
};

const showWinMessage = (secretNumber) => {
  console.log(`
    Ура! Вы угадали число.
    Я действительно загадал ${secretNumber}.
  `);

  readLineInterface.close();
};

const checkAnswer = (secretNumber) => {
  readLineInterface.question('Ваш ответ: ', (inputNumber) => {
    const userAnswer = Number.parseInt(inputNumber);

    if (secretNumber === userAnswer) {
      return showWinMessage(secretNumber);
    }

    console.log('Промазал. Попробуй ещё.');
    checkAnswer(secretNumber);
  });
};

const startGame = () => {
  console.log(welcomeText);

  readLineInterface.question('Максимальное число: ', (maxNumber) => {
    const myNumber = getRandomNumber(0, Number.parseInt(maxNumber, 10));
    checkAnswer(myNumber);
  });
};

startGame();
```


[inquirer] (https://www.npmjs.com/package/inquirer). С помощью этого вы сможете упростить разработку приложения, где требуется обрабатывать пользовательский ввод во время работы консольного приложения. Выбор значений из списков, разделители вывода, диалоги подтверждения и много других задач для создания интерактивности в консоли уже реализовано в этом пакете.

[commander](https://www.npmjs.com/package/commander). Самый популярный пакет для работы с параметрами, передаваемыми приложению в командной строке. Пакет пригодится, когда требуется организовать поддержку множества параметров (группировка параметров, парсинг и так далее).

#### Консольный отладчик

```bash
node inspect 06-simple-program.js
```
Символ > показывает (см. выделенную строку) строку, которая будет исполнена в данный момент. 

- cont, с — продолжить выполнение;
- next, n — следующий шаг;
- step, s — шагнуть «в» (с заходом в функцию);
- out, o — шагнуть «из» (выйти из функции);
- pause — приостановить выполнение кода;

Для выхода нажмите сочетание клавиш «Ctrl + Shift + C» или введите в консоли .exit (обратите внимание, команда начинается с символа «точка»).

Для установки точки останова предусмотрена команда setBreakpoint или сокращённый вариант sb.

Давайте попробуем установить точку останова на строку с номером 2. Для этого введём команду setBreakpoint и аргументом передадим ей 2.

```bash
setBreakpoint(2)
// или
sb(2)
```
Для просмотра значений перейдём в режим REPL:

```bash
debug> repl
```

Для просмотра содержимого параметра a, введите в консоль a и нажмите enter:

```js
> a
2
```

Выйти из режима repl (ctrl + c) и выполним команду next, то есть перейдём на следующую строку

Полузные команды:

- restart — перезапускает отладку сценария;
- kill — прерывает выполнение сценария;
- watch (expression) — добавляет выражение в список отслеживаемых;
- unwatch (expression) — удаляет выражение из списка отслеживаемых;
- list (n) — выводит n-строк текущего модуля;
- clearBreakpoint (<script_name>, <line_number>) — убрать точку останова в сценарии <script_name> со строки <line_number>;

#### Отладка в Google Chrome

Вбиваем в баш запуск дебагера с остановкой

```bash
$ node --inspect-brk 06-simple-program.js
```

В Chrome забиваем в адресной строке

```bash
 chrome://inspect
```

#### Отладка в VSCode

В случае с Visual Studio Code всё предельно просто. Отладка Node.js-приложений — встроенная возможность, поэтому для старта отладки настраивать ничего не нужно. Достаточно установить точки останова на нужных строках («Run» -> «Toggle breakpoint» или F9) и запустить приложение в режиме отладки — «Run» -> «Start Debugging».

#### Сборник пакетов для nodejs

[Awesome Nodejs](https://github.com/sindresorhus/awesome-nodejs?tab=readme-ov-file#mad-science)


### 2 Цикл событий (Event Loop). Потоки (Streams).

Event loop — это программная конструкция или шаблон проектирования, который ожидает и отправляет события или сообщения в программе. Цикл событий работает, отправляя запрос некоторому внутреннему или внешнему «поставщику событий» (который обычно блокирует запрос до тех пор, пока не поступит событие), а затем вызывает соответствующий обработчик событий («отправляет событие»).

Весь JavaScript-код выполняется в одном потоке. Неважно, пишете вы код для браузера или для Node. Он всегда выполняется в одном единственном потоке. 

Стек — это структура данных, позволяющая хранить упорядоченный набор элементов. Неслучайно немного выше мы проводили аналогию с массивом. Только в структуре «стек» добавление/удаление новых элементов возможно только с одной стороны. Мы не можем удалить элемент из середины коллекции, только сверху. Получается, из стека первым удаляется элемент, который был добавлен последним. Добавление элементов тоже происходит только с одной стороны (последним пришёл, первым вышел).

#### Таймеры

Функция setTimeout во втором параметре (delay) мы передаём количество миллисекунд для задержки выполнения. Это время следует трактовать как минимальное время ожидания, после которого функция будет выполнена. Это следует учитывать при использовании этих функций.

Есть несколько очередей:

- Micro tasks (микрозадачи);
 - Задачи, которые решаются без участия Node API — это всё микрозадачи. Например: nextTick, then (речь о промисах), catch (опять же промисы) и так далее — всё это микрозадачи.
- Macro tasks (макрозадачи);
  - А вот функции вроде setTimeout, функции для работы с файловой системой, сетевое взаимодействие — это макрозадачи. Всё, что реализуется Node API, будет относиться к макрозадачам.

#### Паттерн «Издатель—подписчик»

При рассмотрении реализации паттерна мы не случайно подбирали имена для методов. У класса EventEmitter эти методы называются точно так же. Давайте попробуем переписать класс Pizza. Только в этот раз воспользуемся услугами EventEmitter:

```js
import EventEmitter from 'events';

class Pizza extends EventEmitter {
  // Остальной код остаётся без изменений
}
```

Класс EventEmitter доступен во встроенном модуле events. Поэтому первым делом следует подключить этот модуль. Далее берём наш класс и вместо PubSub наследуемся от EventEmitter. Весь остальной код остаётся без каких-либо изменений. Вы также можете оформить подписку на желаемое событие при помощи метода addListener или on (алиас). Эти методы делают одно и то же, но в среде Node обычно принято использовать второй.

Полезные методы^
- `removeAllListeners()`. Метод позволяет удалить всех подписчиков или подписчиков только с определённого события.
- `eventNames()`. Возвращает массив со списком событий на которые зарегистрированы подписки. Например:
```JavaScript
myPizza.addListener('orderAccept', (data) => console.log(data));
myPizza.addListener('bakingPizza', (data) => console.log(data));

myPizza.addListener('prepareToping', (data) => console.log(data));
myPizza.addListener('done', (data) => console.log(data));

console.log(myPizza.eventNames()); // ['orderAccept', 'bakingPizza', 'prepareToping', 'done']
```
- `once()`. Подобно addListener или on оформляет подписку на событие с одним лишь исключением: это одноразовая подписка. Подписчик будет удалён из списка слушателей после первого срабатывания события.

#### Buffer

Объект Buffer применяется для работы с потоками двоичных данных. Он позволяет читать, записывать и делать с ними другие операции. Создать экземпляр объекта Buffer несложно. Он доступен глобально, поэтому нет необходимости подключать какой-то модуль. 

```js
const buffer = Buffer.alloc(5);
console.log(buffer); // <Buffer 00 00 00 00 00>
```
Запись в созданный буфер

```js
buffer.write('World');
console.log(buffer); // <Buffer 57 6f 72 6c 64>
```

В этом примере мы создаём буфер размером 5 байт и выводим содержимое в консоль. Само собой, пока мы в ней увидим лишь нули. Это первый способ создания собственного буфера.

```js
const anotherBuffer = Buffer.from('Hello');
console.log(anotherBuffer); // <Buffer 48 65 6c 6c 6f>
```

Размер этого буфера составляет тоже 5 байт. Он определился автоматически на основании содержимого. Если внимательно присмотреться к содержимому, то мы увидим, что 48 — это код символа H (вспоминаем про таблицу ASCII) в шестнадцатеричной системе исчисления. 65 — код символа e и так далее.

При записи новых данных в буфер следует помнить: размер буфера не может быть изменён.
Если мы попытаемся записать данных больше, чем может принять буфер, то всё, что не поместится, будет обрезано.

```js
// Создаём буфер из двух байт
const anotherBuffer = Buffer.alloc(2);

// Пытаемся записать большую строку
anotherBuffer.write('Great World');

// Видим, что записалось всего лишь два символа
console.log(anotherBuffer); // <Buffer 47 72>
```

Перезапись заполненного буфера, не на весь объем буфера оставит часть старых данных. В результате выполнения этого кода мы получим строку «CSSL», что вполне ожидаемо. Первые три символа будут заменены, а последний (L) останется на своём положенном месте.


```js
const buffer = Buffer.from('HTML');
buffer.write('CSS');
console.log(buffer.toString()); // CSSL
```

Метода write. Он принимает несколько параметров:
- строка для записи;
- позиция начала записи;
- длина, которая будет записана;
- кодировка. По умолчанию всегда применяется utf8.

Cтроку CSS в буфер, который уже содержит HTML. Только на этот раз запись начнём со второй позиции.
 
```js
const buffer = Buffer.from('HTML');
buffer.write('CSS', 1);
console.log(buffer.toString(), 1, 3);
```

Что такое строка? В первую очередь — набор символов. Но как его представить в виде единиц и нулей? Да очень просто. У каждого символа есть свой цифровой код. Он определяется на основании таблицы кодировки (Unicode, ASCII и так далее). Так вот, раз у символа есть цифровой код, то его несложно преобразовать в двоичный вид. Например, чтобы получить код символа I мы можем воспользоваться методом объекта String — charCodeAt:

```js
'I'.charCodeAt(0); // 73
```

